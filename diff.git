diff --git a/nemu/src/monitor/sdb/expr.c b/nemu/src/monitor/sdb/expr.c
index ec12cc8..1bfa2fd 100644
--- a/nemu/src/monitor/sdb/expr.c
+++ b/nemu/src/monitor/sdb/expr.c
@@ -9,7 +9,6 @@
 
 enum {
 
-  /* TODO: Add more token types */
   /* 优先级从高到低 */
   TK_NOTYPE = 256,
   TK_MINUS,
@@ -25,11 +24,6 @@ static struct rule {
   const char *regex;
   int token_type;
 } rules[] = {
-
-  /* TODO: Add more rules.
-   * Pay attention to the precedence level of different rules.
-   */
-
   {"\\(", '('},         // left bracket 40
   {"\\)", ')'},         // right bracket 41
   {"\\*", '*'},         // mul 42
@@ -209,10 +203,6 @@ word_t eval(int p, int q, bool *success){
     return 0;
   }
   else if (p == q) {
-    /* Single token.
-     * For now this token should be a number.
-     * Return the value of the number.
-     */
     word_t immediate = 0;
     if(tokens[p].type == TK_HEX)//16进制情况
       sscanf(tokens[p].str, "%lxu", &immediate);
@@ -227,9 +217,6 @@ word_t eval(int p, int q, bool *success){
     return immediate;
   }
   else if (check_parentheses(p, q) == true) {
-    /* The expression is surrounded by a matched pair of parentheses.
-     * If that is the case, just throw away the parentheses.
-     */
     IFDEF(TEST_EXPR, Log("Check good p:%d,q:%d",p,q));
     return eval(p + 1, q - 1, success); 
   }
@@ -331,171 +318,11 @@ word_t eval(int p, int q, bool *success){
 }
 
 
-// bool is_opr_pri(int pri, int type){
-//   switch (pri)
-//   {
-//   case 10://第10优先级（立即数）
-//     if (type == TK_NUM || type == TK_HEX) return true;
-//     else return false;
-//   case 7:
-//     if (type == TK_EQ || type == TK_NEQ) return true;
-//     else return false;
-//   case 4://第4优先级（加减逻辑法）
-//     if (type == '+' || type == '-' || type == TK_AND || type == TK_XOR || type == TK_OR) return true;
-//     else return false;
-//   case 3://第3优先级（乘除法）
-//     if (type == '*' || type == '/') return true;
-//     else return false;
-//   case 2://第2优先级（单操作数）
-//     if (type == TK_MINUS || type == TK_DERE) return true;
-//     else return false;
-//   case 1://第1优先级（括号）
-//     if (type == '(' || type == ')') return true;
-//     else return false;
-//   default:
-//     return false;
-//   }
-// }
-
-// word_t eval(int p, int q, bool *success){
-//   if (p > q) {
-//     /* Bad expression */
-//     return -1;
-//   }
-//   else if (p == q) {
-//     /* Single token.
-//      * For now this token should be a number.
-//      * Return the value of the number.
-//      */
-//     word_t immediate = 0;
-//     if(tokens[p].type == TK_HEX)//16进制情况
-//       sscanf(tokens[p].str, "%lxu", &immediate);
-//     else if(tokens[p].type == TK_REG){//reg情况
-//       char buff[8];
-//       strncpy(buff, tokens[p].str + 1, 4);
-//       immediate = isa_reg_str2val(buff, success);
-//     }
-//     else//10进制情况
-//       sscanf(tokens[p].str, "%lu", &immediate);
-//     Assert(immediate!=-1, "*** ERROR: Token number overflow! ***");
-//     return immediate;
-//
-//   }
-//   else if (check_parentheses(p, q) == true) {
-//     /* The expression is surrounded by a matched pair of parentheses.
-//      * If that is the case, just throw away the parentheses.
-//      */
-//     Log("Check good p:%d,q:%d",p,q);
-//     return eval(p + 1, q - 1, success);
-//
-//   }
-//   else {
-//     int64_t val1;
-//     int64_t val2;
-//     int op = -1;
-//     int op_type = -1;
-//
-//     int64_t count = 0;
-//     for(int i = p; i <= q; i++){
-//       //单符号逻辑
-//       if(tokens[i].type == '-' || tokens[i].type == '*'){
-//         //单运算符在第0位的情况
-//         if(i == 0)
-//           tokens[i].type = (tokens[i].type == '-') ? TK_MINUS :
-//                             (tokens[i].type == '*') ? TK_DERE : tokens[i].type;
-//         //去除前一位是数字位和括号位情况
-//         else if(i > 0 && !is_opr_pri(10,tokens[i-1].type) && !is_opr_pri(1,tokens[i-1].type)){
-//             tokens[i].type = (tokens[i].type == '-') ? TK_MINUS :
-//                               (tokens[i].type == '*') ? TK_DERE : tokens[i].type;
-//         }
-//       }
-//       else if(!is_opr_pri(10, tokens[i].type) && !is_opr_pri(2,tokens[i].type) && !is_opr_pri(1,tokens[i].type)){//其他意外排除(即两个符号连在一起)
-//         if(i == 0){
-//           Log("*** ERROR Operator connection i:%d:%c%c ***",i , tokens[i-1].type, tokens[i].type);
-//           *success = false;
-//           return -1;
-//         }
-//         else if(i > 0 && !is_opr_pri(10,tokens[i-1].type) && !is_opr_pri(1,tokens[i-1].type)){//去除前一位是数字位情况
-//             Log("*** ERROR Operator connection i:%d:%c%c ***",i , tokens[i-1].type, tokens[i].type);
-//             *success = false;
-//             return -1;
-//         }
-//       } 
-//       //最外层的最低时记录op
-//       if(count == 0){
-//         if (is_opr_pri(4, tokens[i].type)){//第4优先级（加减逻辑法），
-//           op = i;
-//         } 
-//         else if (is_opr_pri(3, tokens[i].type)){//第3优先级（乘法），
-//           if(tokens[op].type != '+' && tokens[op].type != '-')//检测是否存在低优先级，
-//             op = i;                                           //如果有则op不变,从而进一步递归
-//         }
-//         else if (is_opr_pri(2, tokens[i].type)){//第2优先级（单操作数），
-//           if(!is_opr_pri(3, tokens[op].type)//检测op处是否存在低优先级，
-//           && !is_opr_pri(4, tokens[op].type)){//如果有则op不变,从而进一步递归
-//             if((i > p && tokens[i-1].type != TK_MINUS) || i == p)//-- 分割为右处 -(-)
-//               op = i;
-//           }
-//         }
-//       }
-//
-//       //规则递进
-//       if(tokens[i].type == '(')
-//         count += 1;
-//       else if(tokens[i].type == ')')
-//         count -= 1;
-//       //printf("%c%s",tokens[i].type,tokens[i].str);
-//     }
-//     //找不到主运算符
-//     if(op<0){
-//       Log("*** ERROR Cannot get main operation position! ***");
-//       *success = false;
-//       return -1;
-//     }
-//     //递归求值
-//     val1 = eval(p, op - 1, success);
-//     val2 = eval(op + 1, q, success);
-//     //类型转移
-//     op_type = tokens[op].type;
-//     // printf("主运算符:%c,val1:%ld,val2:%ld\n",op_type,val1,val2);
-//     switch (op_type) {
-//       case '+':       return val1 + val2;
-//       case '-':       return val1 - val2;
-//       case '*':       return val1 * val2;
-//       case '/':       return val1 / val2;
-//       case TK_AND   : return val1 && val2;
-//       case TK_XOR   : return val1 ^ val2;
-//       case TK_OR    : return val1 || val2;
-//       case TK_MINUS : return (-1) * val2;
-//       case TK_DERE  : return (*((word_t *)val2));
-//       default:{
-//         Log("*** ERROR: Operation %c not found ! ***",op_type);
-//         *success = false;
-//         return -1;
-//       }  
-//     }
-//   }
-// }
-
-//    (1+2)-(3+4)
-// e  (1+5)*2+(6-3)
-//    012345678901234
-// b expr.c:188
-
-// long long的最大值： 9223372036854775807
-// long long的最小值： -9223372036854775808
-// unsigned long long的最大值： 1844674407370955161
-
-
 
 word_t expr(char *e, bool *success) {
   if (!make_token(e)) {
     *success = false;
     return 0;
   }
-
-
-  word_t result = eval(0,nr_token-1,success);
-  // printf("result:%ld\n",result);
-  return result;
+  return eval(0,nr_token-1,success);
 }
